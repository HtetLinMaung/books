# Chapter 4

# Running Docker Containers

In this chapter, we will discuss Docker containers, running containers, container management commands, container networking, and Docker data volumes.

## What is a Docker container?

A Docker container is a running instance of a Docker image. Containers are isolated, lightweight, and portable units that package up the application code, runtime, libraries, and dependencies required to run the application. Containers are designed to be ephemeral, meaning that once they are stopped or removed, all changes made to their filesystem are discarded. This makes them ideal for running stateless applications or services, where data persistence is not required, or for situations where data is stored outside the container, such as in a database or file storage service.

## Running Docker containers

To run a Docker container from an image, use the `docker run` command followed by the image name and tag:

```bash
docker run my-image:my-tag
```

By default, containers run in the foreground and their output is displayed in the terminal. To run a container in the background, use the -d (detached) flag:

```bash
docker run -d my-image:my-tag
```

To expose a container's network ports to the host, use the `-p` flag followed by the host port, a colon, and the container port:

```bash
docker run -d -p 8080:8080 my-image:my-tag
```

In this example, port 8080 on the host is mapped to port 8080 on the container.

## Container management commands

Docker provides several commands to manage the lifecycle of containers:

- `docker ps`: Lists running containers. Use the `-a` flag to list all containers, including stopped ones.
- `docker stop [CONTAINER_ID]`: Stops a running container.
- `docker start [CONTAINER_ID]`: Starts a stopped container.
- `docker rm [CONTAINER_ID]`: Removes a container. Containers must be stopped before they can be removed.
- `docker logs [CONTAINER_ID]`: Shows the logs of a container. Use the -f flag to follow the logs in real-time.
- `docker exec [CONTAINER_ID] [COMMAND]`: Executes a command inside a running container.

## Container networking

By default, Docker containers are isolated from the host system and other containers, but they can communicate with each other and the outside world through networking. Docker creates a default network called bridge that allows containers to communicate with each other and the host using IP addresses and ports.

To connect containers to a user-defined network, first create the network using the `docker network create` command:

```bash
docker network create my-network
```

Then, run containers with the `--network` flag followed by the network name:

```bash
docker run -d --network my-network my-image:my-tag
```

Containers connected to the same network can communicate with each other using their container names or IP addresses.

## Docker data volumes

Docker provides a mechanism called data volumes to persist data generated by and used by containers. Data volumes are created and managed by Docker and are stored on the host system. They can be mounted inside containers, allowing containers to read and write data from the volume.

To create a data volume, use the `docker volume create` command:

```bash
docker volume create my-volume
```

To mount a data volume inside a container, use the `-v` flag followed by the volume name, a colon, and the container path:

```bash
docker run -d -v my-volume:/data my-image:my-tag
```

In this example, the data volume `my-volume` is mounted at `/data` inside the container. Any files written to `/data` will be stored in the data volume and persist even after the container is stopped or removed.

Data volumes can be shared between multiple containers, making it easy to share data between containers or to backup and restore data. When a container is removed, the data volume is not automatically deleted, allowing the data to be reused by other containers or recovered later.

To list all data volumes on the host, use the `docker volume ls` command:

```bash
docker volume ls
```

To remove a data volume, use the `docker volume rm` command followed by the volume name:

```bash
docker volume rm my-volume
```

Note that removing a data volume will delete all data stored in the volume.

Another method to persist data in containers is by using bind mounts. Bind mounts are similar to data volumes but instead of being managed by Docker, they directly map a host directory to a container directory. To use a bind mount, replace the volume name with the host directory path in the `-v` flag:

```bash
docker run -d -v /path/on/host:/data my-image:my-tag
```

In this example, the host directory `/path/on/host` is mapped to the container directory `/data`. Any files written to `/data` will be stored on the host system and accessible from other containers or applications.

## Summing up

In Chapter 4, we explored running Docker containers, which are instances of Docker images. We discussed how to run containers, both in the foreground and background, as well as exposing their network ports to the host. We covered various container management commands, including listing, starting, stopping, and removing containers. We also explored container networking and how to create and connect containers to user-defined networks. Finally, we discussed Docker data volumes and bind mounts, which enable data persistence and sharing between containers.

## Knowledge Test

1. Run an instance of the `nginx` web server using Docker:
   a. Pull the latest `nginx` image from Docker Hub.
   b. Run a container from the `nginx` image and expose its port 80 to the host's port 8080.
   c. Open a web browser and navigate to `http://localhost:8080`. Verify that the default Nginx welcome page is displayed.
   d. Stop and remove the `nginx` container.
2. Create a user-defined network and run two containers connected to it:
   a. Create a user-defined network named `my-network`.
   b. Run two instances of the `alpine` image on `my-network`. Name them `alpine-1` and `alpine-2`.
   c. Use the `docker exec` command to run `ping alpine-2` inside `alpine-1` and verify that the two containers can communicate with each other.
   d. Stop and remove both `alpine` containers and delete `my-network`.
3. Use data volumes to persist data:
   a. Create a data volume named `my-data`.
   b. Run a container from the `alpine` image, mounting `my-data` at `/data`.
   c. Use the `docker exec` command to create a file named `hello.txt` inside the `/data` directory in the container.
   d. Stop and remove the `alpine` container.
   e. Run another `alpine` container, again mounting `my-data` at `/data`.
   f. Use the `docker exec` command to verify that `hello.txt` is present in the `/data` directory in the new container.
   g. Stop and remove the second `alpine` container and delete the `my-data` volume.
4. Use bind mounts to persist data:
   a. Create a directory named `host-data` on your host machine.
   b. Run a container from the `alpine` image, mounting the `host-data` directory at `/data` in the container using a bind mount.
   c. Use the `docker exec` command to create a file named `hello.txt` inside the `/data` directory in the container.
   d. Verify that the `hello.txt` file is present in the `host-data` directory on your host machine.
   e. Stop and remove the `alpine` container.
